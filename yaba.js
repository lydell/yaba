;(function(){

/**
 * Require the given path.
 *
 * @param {String} path
 * @return {Object} exports
 * @api public
 */

function require(path, parent, orig) {
  var resolved = require.resolve(path);

  // lookup failed
  if (null == resolved) {
    orig = orig || path;
    parent = parent || 'root';
    var err = new Error('Failed to require "' + orig + '" from "' + parent + '"');
    err.path = orig;
    err.parent = parent;
    err.require = true;
    throw err;
  }

  var module = require.modules[resolved];

  // perform real require()
  // by invoking the module's
  // registered function
  if (!module._resolving && !module.exports) {
    var mod = {};
    mod.exports = {};
    mod.client = mod.component = true;
    module._resolving = true;
    module.call(this, mod.exports, require.relative(resolved), mod);
    delete module._resolving;
    module.exports = mod.exports;
  }

  return module.exports;
}

/**
 * Registered modules.
 */

require.modules = {};

/**
 * Registered aliases.
 */

require.aliases = {};

/**
 * Resolve `path`.
 *
 * Lookup:
 *
 *   - PATH/index.js
 *   - PATH.js
 *   - PATH
 *
 * @param {String} path
 * @return {String} path or null
 * @api private
 */

require.resolve = function(path) {
  if (path.charAt(0) === '/') path = path.slice(1);

  var paths = [
    path,
    path + '.js',
    path + '.json',
    path + '/index.js',
    path + '/index.json'
  ];

  for (var i = 0; i < paths.length; i++) {
    var path = paths[i];
    if (require.modules.hasOwnProperty(path)) return path;
    if (require.aliases.hasOwnProperty(path)) return require.aliases[path];
  }
};

/**
 * Normalize `path` relative to the current path.
 *
 * @param {String} curr
 * @param {String} path
 * @return {String}
 * @api private
 */

require.normalize = function(curr, path) {
  var segs = [];

  if ('.' != path.charAt(0)) return path;

  curr = curr.split('/');
  path = path.split('/');

  for (var i = 0; i < path.length; ++i) {
    if ('..' == path[i]) {
      curr.pop();
    } else if ('.' != path[i] && '' != path[i]) {
      segs.push(path[i]);
    }
  }

  return curr.concat(segs).join('/');
};

/**
 * Register module at `path` with callback `definition`.
 *
 * @param {String} path
 * @param {Function} definition
 * @api private
 */

require.register = function(path, definition) {
  require.modules[path] = definition;
};

/**
 * Alias a module definition.
 *
 * @param {String} from
 * @param {String} to
 * @api private
 */

require.alias = function(from, to) {
  if (!require.modules.hasOwnProperty(from)) {
    throw new Error('Failed to alias "' + from + '", it does not exist');
  }
  require.aliases[to] = from;
};

/**
 * Return a require function relative to the `parent` path.
 *
 * @param {String} parent
 * @return {Function}
 * @api private
 */

require.relative = function(parent) {
  var p = require.normalize(parent, '..');

  /**
   * lastIndexOf helper.
   */

  function lastIndexOf(arr, obj) {
    var i = arr.length;
    while (i--) {
      if (arr[i] === obj) return i;
    }
    return -1;
  }

  /**
   * The relative require() itself.
   */

  function localRequire(path) {
    var resolved = localRequire.resolve(path);
    return require(resolved, parent, path);
  }

  /**
   * Resolve relative to the parent.
   */

  localRequire.resolve = function(path) {
    var c = path.charAt(0);
    if ('/' == c) return path.slice(1);
    if ('.' == c) return require.normalize(p, path);

    // resolve deps by returning
    // the dep in the nearest "deps"
    // directory
    var segs = parent.split('/');
    var i = lastIndexOf(segs, 'deps') + 1;
    if (!i) i = 0;
    path = segs.slice(0, i + 1).join('/') + '/deps/' + path;
    return path;
  };

  /**
   * Check if module is defined at `path`.
   */

  localRequire.exists = function(path) {
    return require.modules.hasOwnProperty(localRequire.resolve(path));
  };

  return localRequire;
};
require.register("yaba/lib/yaba.js", function(exports, require, module){
// Generated by CoffeeScript 1.6.3
/*
Copyright 2013 Simon Lydell

This file is part of yaba.

yaba is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser
General Public License as published by the Free Software Foundation, either version 3 of the
License, or (at your option) any later version.

yaba is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the
implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General
Public License for more details.

You should have received a copy of the GNU Lesser General Public License along with yaba. If not,
see <http://www.gnu.org/licenses/>.
*/

var clean, getExpression, parseStack, yaba;

parseStack = require("parse-stack");

getExpression = require("./getExpression");

yaba = function(value) {
  var assertionError, error, expression, message, stack;
  yaba.runs += 1;
  if (value) {
    clean();
    return;
  }
  try {
    throw new Error;
  } catch (_error) {
    error = _error;
  }
  try {
    stack = parseStack(error);
    if (stack) {
      expression = getExpression(stack[1]);
    }
  } catch (_error) {
    error = _error;
    if (typeof console !== "undefined" && console !== null) {
      console.log("yaba: " + error);
    }
  }
  message = expression || ("Assertion " + yaba.runs + " failed");
  if (yaba.message) {
    message += " -- " + yaba.message;
  }
  assertionError = new Error(message);
  assertionError.yaba = yaba.error;
  assertionError.actual = yaba.actual;
  assertionError.expected = yaba.expected;
  assertionError.showDiff = true;
  clean();
  throw assertionError;
};

yaba.runs = 0;

yaba.error = {};

clean = function() {
  return yaba.actual = yaba.expected = yaba.message = void 0;
};

module.exports = yaba;

});
require.register("yaba/lib/getExpression.js", function(exports, require, module){
// Generated by CoffeeScript 1.6.3
/*
Copyright 2013 Simon Lydell

This file is part of yaba.

yaba is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser
General Public License as published by the Free Software Foundation, either version 3 of the
License, or (at your option) any later version.

yaba is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the
implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General
Public License for more details.

You should have received a copy of the GNU Lesser General Public License along with yaba. If not,
see <http://www.gnu.org/licenses/>.
*/

var getExpression, readFileSync, validate;

readFileSync = require("./readFileSync");

getExpression = function(_arg) {
  var additionalLinesRegex, columnNumber, emptyLine, expression, file, filepath, indentation, lastLine, lastMatchWasLastLine, line, lineNumber, match, moreIndentedLine, _base, _i, _len, _ref, _ref1, _ref2, _ref3;
  filepath = _arg.filepath, lineNumber = _arg.lineNumber, columnNumber = _arg.columnNumber;
  if (typeof filepath !== "string") {
    throw new TypeError("The file path (`" + filepath + "`) must be a string.");
  }
  file = (_base = getExpression.fileCache)[filepath] != null ? (_base = getExpression.fileCache)[filepath] : _base[filepath] = getExpression.readFileSync(filepath, "utf-8").split(/\r\n|\r|\n/);
  validate(lineNumber, "line number", file.length, "file");
  lineNumber -= 1;
  line = file[lineNumber];
  indentation = line.match(/^\s*/)[0];
  if (columnNumber != null) {
    validate(columnNumber, "column number", line.length, "line");
    columnNumber -= 1;
  } else {
    columnNumber = indentation.length;
  }
  expression = [];
  expression.push(line.slice(columnNumber));
  additionalLinesRegex = RegExp("^(?:(\\s*)|" + indentation + "(?:(\\s+.*)|(['\"\\s]*[)}\\]].*)))$");
  lastMatchWasLastLine = false;
  _ref = file.slice(lineNumber + 1);
  for (_i = 0, _len = _ref.length; _i < _len; _i += 1) {
    line = _ref[_i];
    _ref2 = (_ref1 = line.match(additionalLinesRegex)) != null ? _ref1 : [], match = _ref2[0], emptyLine = _ref2[1], moreIndentedLine = _ref2[2], lastLine = _ref2[3];
    if (match == null) {
      break;
    }
    if (lastMatchWasLastLine && lastLine) {
      break;
    }
    expression.push((_ref3 = emptyLine != null ? emptyLine : moreIndentedLine) != null ? _ref3 : lastLine);
    lastMatchWasLastLine = lastLine != null;
  }
  return expression.join("\n").replace(/\s+$/, "");
};

getExpression.fileCache = {};

getExpression.readFileSync = readFileSync;

validate = function(number, numberName, limit, limitName) {
  if (!(typeof number === "number" && Math.floor(number) === number)) {
    throw new TypeError("The " + numberName + " (`" + number + "`) must be a whole number.");
  }
  if (!((1 <= number && number <= limit))) {
    throw new RangeError("The " + numberName + " (`" + number + "`) must be within the " + limitName + " (max " + limit + ").");
  }
};

module.exports = getExpression;

});
require.register("yaba/lib/readFileSync.js", function(exports, require, module){
// Generated by CoffeeScript 1.6.3
/*
Copyright 2013 Simon Lydell

This file is part of yaba.

yaba is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser
General Public License as published by the Free Software Foundation, either version 3 of the
License, or (at your option) any later version.

yaba is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the
implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General
Public License for more details.

You should have received a copy of the GNU Lesser General Public License along with yaba. If not,
see <http://www.gnu.org/licenses/>.
*/

var readFileSync;

if (typeof XMLHttpRequest === "function") {
  readFileSync = function(path) {
    var request;
    request = new XMLHttpRequest;
    request.open("GET", path, false);
    request.send(null);
    if (request.status < 400) {
      return request.responseText;
    } else {
      throw new Error("Could not fetch " + path + ":\n" + request.responseText);
    }
  };
} else {
  readFileSync = require("fs").readFileSync;
}

module.exports = readFileSync;

});
require.alias("yaba/lib/yaba.js", "yaba/index.js");if (typeof exports == "object") {
  module.exports = require("yaba");
} else if (typeof define == "function" && define.amd) {
  define(function(){ return require("yaba"); });
} else {
  this["yaba"] = require("yaba");
}})();